---
title: Django入门笔记3-数据库连接与DateBase API
date: 2020-08-03
tags:
 - Django Restful Framework
 - Django
 - Python
categories:
 - 后端
---
![How to create a new project in Django | Hacker Noon](https://i.loli.net/2020/08/03/sZLxCgopYiE9Qcy.jpg)
<!-- more -->
# Django入门笔记3-数据库连接与DateBase API

## 数据库连接

**MySQL**

```bash
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mydatabase',
        'USER': 'mydatabaseuser',
        'PASSWORD': 'mypassword',
        'HOST': '127.0.0.1',
        'PORT': '3306',
    }
}
```

**PostgreSQL**

```bash
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydatabase',
        'USER': 'mydatabaseuser',
        'PASSWORD': 'mypassword',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
```

**MongoDB**

```bash
DATABASES = {
    'default': {
        'ENGINE': None, # 把默认的数据库连接至为None
    }
}
from mongoengine import connect
connect('test') # 连接的数据库名称
```

编写 `model.py` 和 `[serializer.py](http://serializer.py)` 创建模型和序列化

初始化模型及数据库

创建映射文件

```bash
python manage.py makemigrations
```

将映射文件中的映射到数据库中

```bash
python manage.py migrate
```

## DateBase API

创建`model`

```python
from django.db import models
class Blog(models.Model):
  name = models.CharField(max_length=100)
  tagline = models.TextField()
  def __str__(self):
    return self.name

class Author(models.Model):
  name = models.CharField(max_length=200)
  email = models.EmailField()
  def __str__(self):
    return self.name

class Entry(models.Model):
  blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
  headline = models.charField(max_length=255)
  body_text = models.TextField()  
  pub_date = models.DateField()
  mod_date = models.DateField()
  authors = models.ManyToManyField(Author)
  n_comments = models.IntergerField()
  n_pingbacks = models.IntegerField()
  rating = models.IntegerField()
  def __str__(self):
    return self.headline

class EntryDetail(models.Model):
  entry = models.OneToOneField(Entry, on_delete=models.CASCADE)
  details = models.TextField()1234567891011121314151617181920212223242526272829
```

### **创建对象**

### **save**

需遵循如下步骤：

1. 创建一个类的实例
2. 在这个实例上调用`save()`

```bash
# 创建实例
>>> b1=Blog(name="Beatles Blog", tagline = "all the latest Beatles news.")
>>> b2=Blog(name="Sue Blog", tagline = "all latest news about Sue.")
>>> b3=Blog(name="Computer Science", tagline="Hello World!")

# 保存对象
>>> b1.save()
>>> b2.save()
>>> b3.save()
```

这在幕后执行了 INSERT SQL 语句。Django 在你显式调用 save() 才操作数据库。

### **复制已有对象**

将想复制的对象的`pk`设为`None`，然后`save()`即可。

```
>>> b = Blog.objects.all().get(pk=4)
>>> b.pk = None
>>> b.save()
```

需要注意的是， 这种方法并不会复制对象的`ManyToManyField`等属性，因此针对`ManyToMany`的情况，我们可以：

```
entry = Entry.objects.all()[0]
>>> old_authors = entry.authors.all()
>>> entry.pk = None
>>> entry.save()
>>> entry.authors.set(old_authors)12345
```

而`OneToOne`的情况，我们可以：

```
>>> EntryDetail.objects.create(entry=Entry.objects.all()[0], details="None")
<EntryDetail: EntryDetail object (1)>
>>> detail = EntryDetail.objects.all()[0]
>>> detail.pk=None
>>> detail.entry=Entry.objects.all()[1]
>>> detail.save()123456
```

---

### **查询对象**

在Django中，每一个`model`都至少有一个Manager，默认有一个Manager叫`objects`（即`objects`是`django.db.models.manager.Manager`的实例），我们通过调用这个变量的方法可以获得一个包含对象集合的`QuerySet`

### **获得所有对象**

```
>>> Blog.objects.all()
<QuerySet [<Blog: Beatles Blog>, <Blog: Sue Blog>, <Blog: Computer Science>]>12
```

### **获得满足过滤条件的部分对象**

1. `filter` 返回满足条件的对象集合
2. `exclude` 在所有对象的集合中排除满足条件的对象集合并返回

```
>>> Blog.objects.filter(name="Computer Science")
<QuerySet [<Blog: Computer Science>]>
>>> Blog.objects.exclude(pk=1)
<QuerySet [<Blog: Sue Blog>, <Blog: Compter Science>]>
>>> Blog.objects.exclude(pk=3).filter(name__startswith="Beatles")
<QuerySet [<Blog: Beatles Blog>]>123456
```

上述例子中可以看出：1. 由于`filter()` `exclude()`均返回`QuerySet()`，因此可以链式调用2. 参数形式为`field__lookuptype=filter_value`，类似SQL语句中`WHERE`后面的写法。3. 关于`name__startswith="Beatles"`，后面会有讲解。

另外有一点需要注意，创建一个QuerySet不涉及任何数据库操作，只有在使用它的时候，才会去访问数据库。

```
>>> q = Blog.objects.filter(name="Computer Science")
>>> q = q.exclude(pk=1)
>>> print(q)
<QuerySet []>1234
```

前面两句都是在创建一个QuerySet，只有最后一句才使用了它，因此整段代码只有在最后一句才真正访问了数据库。

### **获得某一个对象**

如果能够确定某种过滤条件能而且只能返回一个对象，我们可以使用`get()`

```
>>> Blog.objects.get(pk=1)
<Blog: Beatles Blog>
>>> Blog.objects.filter(pk=1)[0]
<Blog: Beatles Blog>1234
```

上述例子中，我们似乎可以看出`get()`与`filter()`+`[0]`可以做同一件事情，事实不是这样的，我们再举一个例子：

```
>>> Blog.objects.get(pk=4)
...
blog.models.DoesNotExist: Blog matching query does not exist.
>>> Blog.objects.get(name__endswith="Blog")
...
blog.models.MultipleObjectsReturned: get() returned more than one Blog -- it returned 2!
>>> Blog.objects.filter(pk=4)
<QuerySet []>
>>> Blog.objects.filter(pk=4)[0]
...
IndexError: list index out of range1234567891011
```

可以看出`get()`更加严格，无论是找不到对象，可以返回的对象不止一个，均会报错（`DoesNotExist` `MultipleObjectsReturned`）

### **限制返回的对象数量**

1. 返回前2个对象

```
>>> Blog.objects.all()[:2]
<QuerySet [<Blog: Beatles Blog>, <Blog: Sue Blog>]>12
```

1. 返回第2个到第3个对象

```
>>> Blog.objects.all()[1:3]
<QuerySet [<Blog: Sue Blog>, <Blog: Compter Science>]>12
```

1. 返回第三个对象

```
>>> Blog.objects.all()[2]
<Blog: Compter Science>12
```

---

### **更多查找条件**

我们在写一个SQL语句时，WHERE部分不仅仅局限于`=`，比如：

```
WHERE pub_date <= '2018-02-19'WHERE 12
```

那么如何在Django中表示更多的查找条件呢？我们使用上文提到过的如下形式：

```
field__lookuptype=filter_value1
```

### **lte**

```
>>> Entry.objects.filter(pub_date__lte='2006-01-01')
<QuerySet []>12
```

### **exact**

即相等

```
>>> Entry.objects.filter(body_text__exact="None")
<QuerySet [<Entry: Beatles' first song>]>12
```

相当于

```
>>> Entry.objects.filter(body_text="None")
<QuerySet [<Entry: Beatles' first song>]>12
```

### **iexact**

在忽略大小写的情况下，是否相等。

```
>>> Entry.objects.filter(body_text__iexact="none")
<QuerySet [<Entry: Beatles' first song>]>12
```

### **contains**

字符串中是否包含给定字符串，相当于SQL语句中的`LIKE`

```
>>> Entry.objects.filter(body_text__contains="No")
<QuerySet [<Entry: Beatles' first song>]>12
```

### **icontains**

在忽略大小写的情况下，字符串中是否包含给定字符串。

### **startswith**

字符串是否以给定字符串开头

### **endswith**

字符串是否以给定字符串结尾

### **istartswith**

在忽略大小写的情况下，字符串是否以给定字符串开头

### **endswith**

在忽略大小写的情况下，字符串是否以给定字符串结尾

### **对象的属性的属性**

当我们通过判断对象的属性的属性是否符合某个条件来查找对象时，不能使用`.`，应使用`__`

```
>>> Entry.objects.filter(blog__name__contains="Sue")
<QuerySet [<Entry: Beatles' first song>]>12
```

### **对象的外键**

当我们通过对象的外键是否符合某个条件来查找对象时，有以下几种方式：1. 上文提到的一种方式

```
>>> Entry.objects.filter(blog__name__contains="Sue")
<QuerySet [<Entry: Beatles' first song>]>12
```

1. 如果可以获得外键实例，可直接判断是否相等

```
>>> b = Blog.objects.all().get(pk=2)
>>> Entry.objects.filter(blog=b)
<QuerySet [<Entry: Beatles' first song>]>123
```

1. 如果知道外键的`id`：

```
>>> Entry.objects.filter(blog_id=2)
<QuerySet [<Entry: Beatles' first song>]>12
```

或者

```
>>> Entry.objects.filter(blog=2)
<QuerySet [<Entry: Beatles' first song>]>12
```

或者

```
>>> Entry.objects.filter(blog=b.id)
<QuerySet [<Entry: Beatles' first song>]>12
```

我们可以通过`foreignkeyname_id`的形式获得外键的`id`

### **Q对象**

Q对象可以做更加复杂的匹配，可以封装多个过滤条件。1. 封装单个过滤条件

```
>>> Blog.objects.all().filter(Q(name__startswith="Beatles"))
<QuerySet [<Blog: Beatles Blog>, <Blog: Beatles Blog>]>12
```

1. 与 或 非

```
Q(question__startswith="WHO") | ~Q(question__startswith="WHAT")1
```

1. 多个过滤条件

```
Blog.objects.filter(Q(name__startswith("b")), Q(name__endswith("s")))1
```

当往Q输入多个参数时，它们之间的关系为`AND`

---

### **更新对象**

### **更新单个对象**

**更新普通字段**

```
>>> b.name="Beatles' Blog"
>>> b.save()12
```

### **更新外键**

首先创建一个`Entry`对象：

```
entry = Entry(blog=b, headline="Beatles' first song",  body_text="None",pub_date=datetime.now(),n_comments=4,n_pingbacks=4,rating=4,mod_date=datetime.now())
>>> entry.save()12
```

修改`entry`的外键：

```
b = Blog.objects.all().get(pk=2)
>>> entry.blog = b
>>> entry.save()
>>> Entry.objects.all()[0].blog
<Blog: Sue Blog>12345
```

### **更新多对多字段**

首先新建一个`Author`实例：

```
>>> a1 = Author.objects.create(name="Sue", email="158@qq.com")
>>> a2 = Author.objects.create(name="Bob", email="189@qq.com")12
```

使用`add()`为`authors`字段添加一个实例

```
>>> entry.authors.add(a1, a2)
>>> Entry.objects.all()[0].authors.get(id=1)
<Author: Sue>123
```

需要注意的是：1. `add()`方法后，不需要`save()`2. 这里使用`create()`创建对象，它是`Manager`的一个方法。也不需要`save()`

### **更新多个对象**

使用`update()`并配合`filter()` `all()`等，对一个对象集合进行更新操作。`update()`返回需要更新的对象数（也许不是发生改变的对象数，因为有的对象已经有了最新值）

```
>>> Entry.objects.filter(pub_date__year=2018).update(headline="Everything is the same.")
312
```

需要注意的是，使用这个方法只能更新外键或者没关系型字段

---

### **删除对象**

使用`delete()`来删除的对象，为了避免误删除，`Manager`本身并没有暴露`delete()`方法。`delete()`返回删除的对象数量以及按照对象类型的分类汇总。

### **删除所有对象**

```
>>> Blog.objects.all().delete()
(7, {'blog.Entry_authors': 3, 'blog.EntryDetail': 0, 'blog.Entry': 1, 'blog.Blog': 3})12
```

我们需要注意的是：1. 返回结果显示，此次删除操作删除了7个对象，3个Blog实例，1个Entry实例，3个`Entry_authors`中的对象。2. 默认情况下， `delete()`遵循级联删除的规则，即以被删除对象为外键的对象同时被删除。我们可以通过在定义`model`时添加`on_delete`参数来指定级联规则

### **删除指定对象**

我们可以配合使用`get()` `filter()`等获得指定对象或包含指定对象集的`QuerySet`，然后调用`delete()`

### **SQL**

最后，我们也可以使用原生的SQL在访问数据库。